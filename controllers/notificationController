const { Notification, User, sequelize } = require('../models');
const { sendJson } = require('../utils/helpers');
const { Op } = require('sequelize');

// Create Notification (Admin only or system-generated)
exports.createNotification = async (req, res) => {
  try {
    const { user_id, type, title, message, is_read, related_id, related_type } = req.body;

    if (!user_id || !type || !title || !message) {
      return res.status(400).json(
        sendJson(false, 'user_id, type, title and message are required')
      );
    }

    // Verify user exists
    const [user] = await sequelize.query(`
      SELECT id FROM users WHERE id = :user_id LIMIT 1
    `, {
      replacements: { user_id },
      type: sequelize.QueryTypes.SELECT
    });

    if (!user) {
      return res.status(404).json(
        sendJson(false, 'User not found')
      );
    }

    // For MySQL, we need to first insert then select
    await sequelize.query(`
      INSERT INTO notifications 
        (user_id, type, title, message, is_read, related_id, related_type, created_at, updated_at)
      VALUES 
        (:user_id, :type, :title, :message, :is_read, :related_id, :related_type, NOW(), NOW())
    `, {
      replacements: {
        user_id,
        type,
        title,
        message,
        is_read: is_read || false,
        related_id: related_id || null,
        related_type: related_type || null
      }
    });

    // Get the inserted notification
    const [notification] = await sequelize.query(`
      SELECT * FROM notifications 
      WHERE user_id = :user_id 
      ORDER BY id DESC 
      LIMIT 1
    `, {
      replacements: { user_id },
      type: sequelize.QueryTypes.SELECT
    });

    return res.status(201).json(
      sendJson(true, 'Notification created successfully', {
        notification
      })
    );

  } catch (error) {
    console.error('Create Notification Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to create notification', {
        error: error.message
      })
    );
  }
};

// Get All Notifications for Current User
// Get All Notifications with is_read filter
exports.getNotifications = async (req, res) => {
  try {
    const { type, is_read } = req.query;
    const user_id = req.user.id; // From authenticated user

    let whereClause = 'AND n.user_id = :user_id';
    const replacements = { user_id };

    if (type) {
      whereClause += ' AND n.type = :type';
      replacements.type = type;
    }

    // Add filter for is_read if specified
    if (is_read !== undefined) {
      whereClause += ' AND n.is_read = :is_read';
      replacements.is_read = is_read === 'true';
    }

    const notifications = await sequelize.query(`
      SELECT 
        n.*,
        u.id as "user.id",
        u.username as "user.username",
        u.email as "user.email"
      FROM notifications n
      JOIN users u ON n.user_id = u.id
      WHERE 1=1 ${whereClause}
      ORDER BY n.created_at DESC
    `, {
      replacements,
      type: sequelize.QueryTypes.SELECT
    });

    return res.json(
      sendJson(true, 'Notifications fetched successfully', {
        count: notifications.length,
        notifications
      })
    );
  } catch (error) {
    console.error('Get Notifications Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to fetch notifications', {
        error: error.message
      })
    );
  }
};

// Get Single Notification (Owned by current user)
exports.getNotificationById = async (req, res) => {
  try {
    const { id } = req.params;
    const user_id = req.user.id; // From authenticated user

    const [notification] = await sequelize.query(`
      SELECT 
        n.*,
        u.id as "user.id",
        u.username as "user.username",
        u.email as "user.email"
      FROM notifications n
      JOIN users u ON n.user_id = u.id
      WHERE n.id = :id AND n.user_id = :user_id
      LIMIT 1
    `, {
      replacements: { id, user_id },
      type: sequelize.QueryTypes.SELECT
    });

    if (!notification) {
      return res.status(404).json(
        sendJson(false, 'Notification not found or not owned by user')
      );
    }

    return res.json(
      sendJson(true, 'Notification fetched successfully', {
        notification
      })
    );
  } catch (error) {
    console.error('Get Notification Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to fetch notification', {
        error: error.message
      })
    );
  }
};

// Update Notification (Owned by current user)
exports.updateNotification = async (req, res) => {
  const transaction = await sequelize.transaction();
  try {
    const { id } = req.params;
    const user_id = req.user.id; // From authenticated user

    // First verify notification exists and belongs to user
    const [notification] = await sequelize.query(`
      SELECT * FROM notifications 
      WHERE id = :id AND user_id = :user_id
      LIMIT 1
    `, {
      replacements: { id, user_id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    if (!notification) {
      await transaction.rollback();
      return res.status(404).json(
        sendJson(false, 'Notification not found or not owned by user')
      );
    }

    const { type, title, message, is_read, related_id, related_type } = req.body;

    // Perform the update
    await sequelize.query(`
      UPDATE notifications 
      SET 
        type = COALESCE(:type, type),
        title = COALESCE(:title, title),
        message = COALESCE(:message, message),
        is_read = COALESCE(:is_read, is_read),
        related_id = COALESCE(:related_id, related_id),
        related_type = COALESCE(:related_type, related_type),
        updated_at = NOW()
      WHERE id = :id AND user_id = :user_id
    `, {
      replacements: {
        id,
        user_id,
        type: type || null,
        title: title || null,
        message: message || null,
        is_read: is_read !== undefined ? is_read : null,
        related_id: related_id || null,
        related_type: related_type || null
      },
      transaction
    });

    // Get the updated notification
    const [updatedNotification] = await sequelize.query(`
      SELECT * FROM notifications WHERE id = :id LIMIT 1
    `, {
      replacements: { id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    await transaction.commit();

    return res.json(
      sendJson(true, 'Notification updated successfully', {
        notification: updatedNotification
      })
    );
  } catch (error) {
    await transaction.rollback();
    console.error('Update Notification Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to update notification', {
        error: error.message
      })
    );
  }
};

// Delete Notification (Owned by current user)
exports.deleteNotification = async (req, res) => {
  const transaction = await sequelize.transaction();
  try {
    const { id } = req.params;
    const user_id = req.user.id; // From authenticated user

    // First verify notification exists and belongs to user
    const [notification] = await sequelize.query(`
      SELECT * FROM notifications 
      WHERE id = :id AND user_id = :user_id
      LIMIT 1
    `, {
      replacements: { id, user_id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    if (!notification) {
      await transaction.rollback();
      return res.status(404).json(
        sendJson(false, 'Notification not found or not owned by user')
      );
    }

    await sequelize.query(`
      DELETE FROM notifications 
      WHERE id = :id AND user_id = :user_id
    `, {
      replacements: { id, user_id },
      transaction
    });

    await transaction.commit();

    return res.json(
      sendJson(true, 'Notification deleted successfully')
    );
  } catch (error) {
    await transaction.rollback();
    console.error('Delete Notification Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to delete notification', {
        error: error.message
      })
    );
  }
};

// Mark Single Notification as Read (Owned by current user)
exports.markAsRead = async (req, res) => {
  const transaction = await sequelize.transaction();
  try {
    const { id } = req.params;
    const user_id = req.user.id; // From authenticated user

    // First verify notification exists and belongs to user
    const [notification] = await sequelize.query(`
      SELECT * FROM notifications 
      WHERE id = :id AND user_id = :user_id
      LIMIT 1
    `, {
      replacements: { id, user_id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    if (!notification) {
      await transaction.rollback();
      return res.status(404).json(
        sendJson(false, 'Notification not found or not owned by user')
      );
    }

    // Update the notification
    await sequelize.query(`
      UPDATE notifications 
      SET is_read = true, updated_at = NOW()
      WHERE id = :id AND user_id = :user_id
    `, {
      replacements: { id, user_id },
      transaction
    });

    // Get the updated notification
    const [updatedNotification] = await sequelize.query(`
      SELECT * FROM notifications WHERE id = :id LIMIT 1
    `, {
      replacements: { id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    await transaction.commit();

    return res.json(
      sendJson(true, 'Notification marked as read', {
        notification: updatedNotification
      })
    );
  } catch (error) {
    await transaction.rollback();
    console.error('Mark as Read Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to mark notification as read', {
        error: error.message
      })
    );
  }
};

// Mark All Notifications as Read for Current User
exports.markAllAsRead = async (req, res) => {
  const transaction = await sequelize.transaction();
  try {
    const user_id = req.user.id; // From authenticated user

    // Update all unread notifications for this user
    await sequelize.query(`
      UPDATE notifications 
      SET is_read = true, updated_at = NOW()
      WHERE user_id = :user_id AND is_read = false
    `, {
      replacements: { user_id },
      transaction
    });

    // Get updated count
    const [result] = await sequelize.query(`
      SELECT COUNT(*) as updated_count 
      FROM notifications 
      WHERE user_id = :user_id AND is_read = true
    `, {
      replacements: { user_id },
      type: sequelize.QueryTypes.SELECT,
      transaction
    });

    await transaction.commit();

    return res.json(
      sendJson(true, 'All notifications marked as read', {
        updated_count: result.updated_count
      })
    );
  } catch (error) {
    await transaction.rollback();
    console.error('Mark All as Read Error:', error);
    return res.status(500).json(
      sendJson(false, 'Failed to mark notifications as read', {
        error: error.message
      })
    );
  }
};